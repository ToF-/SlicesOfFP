<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/White.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/default.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<style type="text/css">
p { text-align: left; }
		</style>

	</head>
	<body>
		<div class="reveal">
			<div class="slides">
<section data-markdown data-separator="^----$" data-separator-vertical="^\n--\n$">
          <script type="text/template">
## Slices of Functional Programming
Xavier Détant

Christophe Thibaut


----
### The Texas Hold'em Kata

Given this file `input.txt` :

    Kc 9s Ks Kd 9d 3c 6d 
    9c Ah Ks Kd 9d 3c 6d
    Ac Qc Ks Kd 9d 3c 
    9h 5s 
    4d 2d Ks Kd 9d 3c 6d
    7s Ts Ks Kd 9d


after `runhaskell PokerHands.hs <input.txt`

then the output is

    Kc 9s Ks Kd 9d 3c 6d Full House (winner)
    9c Ah Ks Kd 9d 3c 6d Two Pair
    Ac Qc Ks Kd 9d 3c 
    9h 5s 
    4d 2d Ks Kd 9d 3c 6d Flush
    7s Ts Ks Kd 9d

----
### The Texas Hold'em Kata

in the line: `  8s 9d Th Js Qd Kc Ah  ` 

`T`,`J`,`Q`,`K`,`A` stand for *Ten*, *Jack*, *Queen*, *King*, *Ace*

`h`,`s`,`d`,`c` stand for *Hearts*, *Spades*, *Diamonds*, *Clubs*

Texas Hold'em in five steps:

1. Interpret Strings in terms of Cards
2. Compare Cards (by Rank or by Suit)
3. Find the Category of a Hand (Hand = group of 5 Cards)
4. Find the best Hand in a group of 7 Cards
5. Find the best player in a game

----
### Program = Function Evaluation


Lauch *ghci* and try some functions:


    sqrt 1764 ⏎

    Data.List.subsequences "ABCD" ⏎

    subtract 2 44 ⏎

    subtract 1 (subtract 1 44) ⏎

    6 * (3 + 4) ⏎

    (*) 6 ((+) 3 4) ⏎

    Data.List.insert 42 [1,32,87] ⏎

----
### Writing a test

A short program named *Specs.hs*:

    import Test.Hspec

    main = hspec 
        (describe "a test" 
            (it "should pass" 
                (2+2  `shouldBe` 4)))

Running the test:

    runhaskell Specs ⏎


----
### Sequencing actions with *do*:

    import Test.Hspec

    main = hspec $ do
        describe "a suite" $ do
            it "should pass" $ do
                2+2  `shouldBe` 4
            it "should not fail" $do
                2*2 `shouldBe` 4

----
### Let's write some functions

Write a function *response* that passes this test:

    import Test.Hspec

    main = hspec $ do
        describe "response" $ do
            it "should be a yes or a no" $ do
                response 'N' `shouldBe` False
                response 'n' `shouldBe` False
                response 'Y' `shouldBe` True
                response 'y' `shouldBe` True

----
### Pattern Matching

Patterns allow for expressing distinct cases 


    response 'Y' = True
    response 'y' = True
    response 'N' = False
    response 'n' = False

----
### Lists

A way to collect values of the same type

Ghci:

	1 : 2 : 3 : [] ⏎

	'a' : 'b' : 'c' : "" ⏎

	[4,8] ++ [0,7] ⏎

	head [4,8,0,7] ⏎

	tail [4,8,0,7]  ⏎

    reverse "Hello World" ⏎


----
#### Let's write some functions

Write a function *average* that passes this test:

        describe "average" $ do
            it "should calculate the average" $ do
                average [ ]        `shouldBe` 0.0
                average [2, 4, 12] `shouldBe` 6.0

----
### Let's write some functions

using Pattern Matching to denote cases: 

    average [ ]  = 0.0
    average xs   = sum xs / length xs

----
### Pattern Matching

also allows for deconstructing data 

two examples:

    isOrdered [a,b]   = a <= b
    isOrdered [a,b,c] = isOrdered [a,b] && isOrdered [b,c]

    product []     = 1
    product (x:xs) = x * product xs

----
### Comparing values

Some useful checks about `compare`

    describe "compare" $ do
        it "should compare values of any type of class Ord" $ do
            compare 42 17       `shouldBe` GT
            compare 'A' 'B'     `shouldBe` LT
            compare 11.3 11.3   `shouldBe` EQ

            compare "cat" "dog" `shouldBe` LT

----
### Strings are not Cards!

There's no way that this test can pass:

    describe "using Strings as Cards" $ do
        it "cannot give satisfactory comparisons" $ do
            compare "8d" "9c"  `shouldBe` LT
            compare "8d" "8c"  `shouldBe` EQ
            compare "Ah" "Jc"  `shouldBe` GT

unless we rewrite `compare`

----
### How to compare cards by rank ?

Write a function `rank` that passes this test:


    describe "comparing card by rank" $ do
        it "should follow the rules of poker" $ do
            compare (rank "8d") (rank "6h") `shouldBe` GT
            compare (rank "4d") (rank "4h") `shouldBe` EQ
            compare (rank "9d") (rank "Th") `shouldBe` LT 
            compare (rank "Td") (rank "Jh") `shouldBe` LT 
            compare (rank "Jd") (rank "Qh") `shouldBe` LT 
            compare (rank "Qd") (rank "Kh") `shouldBe` LT 
            compare (rank "Kd") (rank "Ah") `shouldBe` LT 

Hint:

    rank ['A',_] = 14
    rank ['K',_] = 13
    . . .

----
### How to compare cards by suit

Write a function `suit` that passes this test

    describe "comparing card by suit" $ do
        it "should follow the rules of poker" $ do
            suit "8d" == suit "6d" `shouldBe` True
            suit "4d" == suit "4h" `shouldBe` False
            suit "9d" == suit "Tc" `shouldBe` True
            suit "Td" == suit "Js" `shouldBe` False

----
### Types are a way to validate my constructs

We have types:

    rank :: String -> Int
    suit :: String -> Char

But:

- every String value is not a valid Card value
- ` rank False ` or ` rank 3.1415 ` are not legal
- but ` rank "Foo" ` is still legal
- `compare (rank "#&") (rank "18")` == ... ?
- only when comparing fails we know we had incorrect data

----
### Tuples: a way to gather values of different types

Ghci:

	:type (EQ,'@', False) ⏎

	:type ('A',True) ⏎

	fst ('A', True) ⏎

	snd ('A', True)  ⏎

----
### Types are a way to think about the problem
 
A (slighty) better design, with a new function: `Card`

    type Card = (Rank, Suit) 
    type Rank = Int
    type Suit = Char

    rank :: Card -> Rank
    suit :: Card -> Suit

    card :: String -> Card

Better because:

- once conversion is done, the comparing takes care of itself
- bad input is detected at conversion, not in comparisons
- but: you can still do silly things like ` rank (4807,'@') `

----
### Comparing cards by Rank improved

Write the `card` function so that the test pass

    describe "comparing card by rank" $ do
        it "should follow the rules of poker" $ do
            compare (rank (card "8d")) (rank (card "6h")) `shouldBe` GT
            compare (rank (card "4d")) (rank (card "4h")) `shouldBe` EQ
            compare (rank (card "9d")) (rank (card "Th")) `shouldBe` LT 
            compare (rank (card "Td")) (rank (card "Jh")) `shouldBe` LT 
            compare (rank (card "Jd")) (rank (card "Qh")) `shouldBe` LT 
            compare (rank (card "Qd")) (rank (card "Kh")) `shouldBe` LT 
            compare (rank (card "Kd")) (rank (card "Ah")) `shouldBe` LT 

----
### Types as a way to think about a problem

    data Suit = Hearts | Clubs | Diamonds | Spades -- an union type
        deriving (Eq, Show)

    data Rank = Two | Three | Four | Five | Six | Seven | Eight | Nine 
              | Ten | Jack | Queen | King | Ace
        deriving (Eq, Ord, Enum, Show)

    type Card = (Rank, Suit)
    rank = fst
    suit = snd
  

- the type `Card` can have only 52 values.
- once conversion is done, you can only

	- compare by rank order (no illegal rank allowed)
	- compare on equality by suit (no illegal suit allowed)

----
# Checkpoint #1 

We have the proper types to describe our values

We have our main feature: comparing cards

#Well Done!!

----
### Passing Functions to Functions

    import Data.Ord ⏎

    :type compare ⏎

    :type comparing ⏎

    comparing abs (-4) 3 ⏎

    :load PokerHand.hs ⏎

    comparing rank (card "8c") (card "5d") ⏎

the function `rank` is passed to the `comparing` function

----
### Combining Functions

    :type (.) ⏎

    (length . words) "time flies like an arrow" ⏎

    comparing (rank . card) "8c" "5d" ⏎

`(f . g) x == f (g x)` 

----
### Combining Functions

Refactor the test using `comparing` and the `. ` operator

    describe "comparing card by rank" $ do
        it "should follow the rules of poker" $ do
            compare (rank (card "8d")) (rank (card "6h")) `shouldBe` GT
            compare (rank (card "4d")) (rank (card "4h")) `shouldBe` EQ
            compare (rank (card "9d")) (rank (card "Th")) `shouldBe` LT 
            compare (rank (card "Td")) (rank (card "Jh")) `shouldBe` LT 
            compare (rank (card "Jd")) (rank (card "Qh")) `shouldBe` LT 
            compare (rank (card "Qd")) (rank (card "Kh")) `shouldBe` LT 
            compare (rank (card "Kd")) (rank (card "Ah")) `shouldBe` LT 

----
### Mapping a function to a list of values

    :type map ⏎
    map negate [-34,42,17] ⏎

    map sqrt [1,2,3,4,5] ⏎

----
### Collecting Cards

Write the function `cards` such that

    describe "cards" $ do
        it "should collect cards from a string" $ do
            cards "8d Ah Qc"  `shouldBe`
                 [(Eight,Diamonds),(Ace,Hearts),(Queen,Clubs)]

----
### Sorting

    sort [42,3,17,1,22,4,38] ⏎

    sortBy compare "HELLO" ⏎

    sortBy (comparing length) (words "time flies like an arrow") ⏎


----
### Ranks of a hand

Write the function `ranks` such that

    describe "ranks" $ do
        it "should give the sorted ranks of a hand" $ do
            ranks (cards "8d Ah Qc")  `shouldBe` [Eight,Queen,Ace]

----
### Grouping

    group "HELLO" ⏎
    
    (group . sort) "Cats and Dogs"

----
### Groups of Cards

Write the function `groups` such that

    describe "groups" $ do
        it "should obtain groups of ranks from a list of cards, sorted by descending length of group then rank" $ do
            groups (cards "8d Ah Qc 8h 8s")  `shouldBe` [[EIght,Eight,Eight],[Ace],[Queen]]
            groups (cards "8d Ah Qc 8h As")  `shouldBe` [[Ace,Ace][EIght,Eight],[Queen]]

----
### Categorizing groups of Cards

A data type for Category

    data Category = HighCard | OnePair | TwoPairs | ThreeOfAKind | Straight | Flush
                  | FullHouse | FourOfAKind | StraightFlush | RoyalFlush
        deriving (Eq,Ord,Show)

Write the function `category :: [[Rank]] -> Category` such that

    describe "category" $ do
        it "should determine the category of a hand" $ do
            let hs = ["4s 5d Kc Tc 3d"
                     ,"4s Kd Kc Tc 3d"
                     ,"4s Kd Kc Tc Td"
                     ,"Ts Kd Kc Tc Td"
                     ,"Ts Kd Kc Kc 8d"
                     ,"Ts Kd Kc Kc Kd"]
            map (category.groups.cards) hs ==  
                    [HighCard ,OnePair ,TwoPairs
                    ,FullHouse ,ThreeOfAKind ,FourOfAKind]

----
### Special categories

A Straight is like a HighCard except that ranks are forming a sequence, e.g. Th 9d 8c 7s 6s

A Flush is like a HighCard except that all the cards have the same suit, e.g. Kh Jh 9h 7h 6h

A Straight Flush is combines the characteristics of a Straight and a Flush, e.g Th 9h 8h 7h 6h 

A Royal Flush is a Straight Flush starting with an Ace e.g. Ah Kh Qh Jh Th

----
### Guards

Pattern matching can be subjected to conditions, called guards

    power n m | m >= 0    = product (replicate m n)
              | otherwise = error "negative exponent"   

    sign n | n < 0 = -1
           | n > 0 =  1
           | _     =  0

----
### Detecting a Flush

Write the function `flush` such that

    describe "flush" $ do
        it "should detect when all cards in a hand have the same suit" $ do
            flush (cards "8d Ah 4d 3d Ad") `shouldBe` False
            flush (cards "8h Ah 4h 3h Kh") `shouldBe` True

----
### Enum typeclass

    fromEnum False ⏎
    fromEnum True ⏎

    fromEnum Ace ⏎

----
### Detecting a Straight

Given a list of 5 distinct groups of 1 rank each, 
And   the first rank value = the last rank value + 4
Then  the category is Straight

    isStraight [[a],_,_,_,[b]] = fromEnum a == 4 + fromEnum b 
    isStraight _               = False 

----
### Determining a Ranking

Comparing two hands ranking involves comparing their category, and if their categories are equal, comparing the ranks 

    type Ranking = (Category, [Ranks])

    ranking :: [Cards] -> Ranking

Using the `groups`, `reverse`, `sort`, `ranks`, `isStraight`, `isFlush` functions, write the function `ranking` 


        it "should correctly order a list by ranking" $ do
            let s = ["7s 5c 4d 3d 2c" -- lowest High Card
                    ,"As Kc Qd Jd 9c" -- highest High Card
                    ,"2h 2d 5c 4c 3c" -- lowest Pair
                    ,"Ah Ad Kc Qc Jc" -- highest Pair
                    ,"2c 2s 3s 3c 4h" -- lowest Two Pairs
                    ,"Ac As Ks Kc Jh" -- highest Two Pairs
                    ,"2h 2d 2c 4c 3c" -- lowest Three Of A Kind
                    ,"Ah Ad Ac Qc Jc" -- highest Three Of A Kind
                    ,"5h 4s 3d 2c Ah" -- lowest Straight
                    ,"Ah Ks Qd Jc Th" -- highest Straight
                    ,"7c 5c 4c 3c 2c" -- lowest Flush
                    ,"Ac Kc Qc Jc 9c" -- highest Flush
                    ,"2h 2d 2c 3h 3c" -- lowest Full House
                    ,"Ah Ad Ac Kh Kc" -- highest Full House
                    ,"2c 2s 2h 2d 3c" -- lowest Four Of A Kind
                    ,"Ac As Ah Ad Jc" -- highest Four Of A Kind
                    ,"5c 4c 3c 2c Ac" -- lowest Straight Flush
                    ,"Ah Kh Qh Jh Th"] -- Royal Flush
                isStrictlyOrdered [_] = True
                isStrictlyOrdered (x:y:xs) = x < y && isStrictlyOrdered (y:xs) 
                r = map (ranking.cards) s
            isStrictlyOrdered r `shouldBe` True

            </script>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,
                slideNumber: true,
                center: false,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
